# fed-e-task-01-01
part1 js深度剖析 模块一ES6+与ts

// 1、请说出下列最终的执行结果，并解释为什么
var a = [];
for (let i = 0 ; i < 10; i++){
    a[i]= function () {
        console.log(i);
    };
}
a[6]();
// 结果：10
// 因为打印的i始终都是全局作用域中的i，在循环执行完成之后，i累加到了10
// 所以无论打印哪个元素的事件结果都是10
// 如果将i 定义为let类型，就可以将i变成块作用域中的局部变量，a[6]()的打印结果将变为6


// 2、请说出下列最终的执行结果，并解释为什么
var tmp = 123;
if(true){
  console.log(tmp);
  let tmp;
}
// 结果：报引用异常错误--ReferenceError: Cannot access 'tmp' before initialization
// 原因：块级作用域限制，let不会出现变量声明提升的情况
// 在块级作用域中，重新声明了let tmp,在这个块级作用域中 ，必须先声明变量再使用变量



// 3、结合ES6新语法，用最简单的方式找出数组中的最小值
var arr = [12,34,32,89,4];
var iMin = Math.min(...arr);
console.log(iMin);

// 4、请详细说明var,ler,const三种声明变量的方式之间的具体差别
// var是一个全局变量，可以声明提升，也可以在声明之后又重新声明
// let是一个块级作用域中的变量（只能在所声明的块中中被访问，并且不会影响外部的变量），必须先声明变量再使用
// const是一个块级作用域中的只读常量，声明的同时必须设置初始化值；并且声明之后不能再修改，只是不允许声明之后指向一个新的内存地址，可以修改属性成员



// 5、请说出下列最终的执行结果，并解释为什么
var a = 10;
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
//结果：20
//原因：当函数作为对象里面的方法被调用时，它的this是调用该函数的对象。



// 6、简述Symbol类型的用途？
//作用：1）.主要作用是为对象添加独一无二的对象属性名，避免成员对象重复
//      2）.模拟实现对象的私有成员



// 7、说说什么是浅拷贝，什么是深拷贝？
// 浅拷贝：在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象
// 深拷贝：在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量
//变量存储类型分两类
//    ①基本类型：直接存储在栈中的数据。（字符串、布尔值、数字、null、undefined）
//    ②引用类型：将该对象引用地址存储在栈中，然后对象里面的数据存放在堆中。（数组、对象、函数）
// 赋值：获得该对象的引用地址
// =======以下为在博客上查找的资料===========================================
// 拷贝数据主要针对数组和对象两者：
// 1、使用"="直接赋值给一个变量
//       将对象/数组直接赋值给一个变量的时候，复制的是对象/数组的地址值，它们指向的都是同一地址值，故赋值之后，修改拷贝之后的数据会影响原数据（浅拷贝）
// 2、Object.assign(newObj，obj)
//       使用assign拷贝数据，它底层是通过interator进行遍历的，如果对象/数组中有对象/数组时，那么它赋值的还是地址值，故浅拷贝
// 3、Array.prototype.concat（） // let newArr = arr.concat()
//      同理assign
// 4、Array.prototype.slice（） // let newArr = arr.slice()
//      同理assign
// 5、let newObj = JSON.parse（JSON.stringify（obj））
//      因为使用JSON.stringify()会将对象/数组变成字符串，所以再使用JSON.parse()转换后，转换的是基本类型，所以在转换后修改数据是不会影响原数据的，故称为深拷贝（深度克隆）
// 结论：
// 在使用assign、concat、slice时，如果数组/对象中的元素全部是基本类型（不包含数组/对象）时，那么使用他们拷贝数据的话，就是讲基本类型通过遍历的方式拷贝给新的数组/对象，在修改新的数组/对象中的数据是不会影响原数据（深拷贝）；
// 如果被拷贝的数组/对象中含有数组/对象时，那么在遍历的时候，依然赋值的是对象/数组元素的地址值，故修改新的数组/对象的数据是会影响原数据（浅拷贝）
// 【使用concat、slice、assign拷贝数据简述：】
// 修改拷贝后的数组/对象中的数据不含有数组/对象，是深拷贝；
// 修改拷贝后的数组/对象中的数据含有数组/对象，是浅拷贝。
// =======以上为在博客上查找的资料===========================================




// 8、谈谈你是如何理解JS异步编程的，EventLoop是做什么的，什么是宏任务，什么是微任务？
//JS异步编程：异步模式的API不会等待这个任务的结束才开始下一个任务，开启过后就立即往后执行下一个任务，后续逻辑一般会通过毁掉函数的方式定义
//           可以帮助单线程的js语言同时处理大量耗时任务，
//EventLoop：负责监听调用栈和消息队列，一旦调用栈中的所有任务结束了，就会从消息队列取出第一个调用函数压入调用栈
//宏任务：回调队列中的任务被称为宏任务。宏任务执行过程中可以临时加上一些额外的需求，可以选择作为一个新的额宏任务进到队列中执行
//微任务：宏任务执行过程中可以临时加上一些额外的需求，直接在当前任务结束过后立即执行的任务被称为微任务。Promise的回调会作为微任务执行、MutationObserver、process.nextTick.



// 9、 将下面异步代码使用Promise改进？
setTimeout(function (){
    var a = "hello ";
    setTimeout(function (){
        var b = "lagopu ";
        setTimeout(function (){
            var c = "i love u";
            console.log(a + b + c);        
        },10)    
    },10)
},10)
//========代码如下：
const promise = new Promise(function (resolve, reject){
    resolve("hello ")
})
.then(function (value){
    return value + "lagopu "
})
.then(function (value){
    console.log(value+"i love u")
})

// 10、请简述TypeScript与JavaScript之间的关系
//关系：TypeScript是基于JavaScript之上的一门编程语言，是JavaScript的一个超集\扩展集，在JavaScript之上多出来了一套更强大的类型系统以及对ES6+新特性的支持。
//      TypeScript的类型系统避免了在开发过程中有可能的类型异常，重点解决了JavaScript自有的类型的不足,TypeScript大大提高了代码的可靠程度。
//      TypeScript最终编译为原始JavaScript运行，任何一种JavaScript运行环境都支持，不仅支持ES6+新特性，也可以作为原始的TypeScript使用。
//JavaScript自有类型系统的问题：JavaScript是一门弱类型而且是动态类型的语言，本身的类型系统是非常薄弱的，几乎没有任何类型限制，缺失了类型系统的可靠性。JavaScript作为一种脚本语言，没有编译环节。
//弱类型的问题：类型异常在运行时才能发现、类型不确定造成函数作用变化、导致出现对对象索引器的错误用法
//强类型的优势：错误更早暴露（类型异常在编译时就能提前发现）、代码类型更智能，编码更准确、重构更加牢靠、减少不必要的类型判断



// 11、谈谈你所认为的TypeScript优缺点
// 优点：1）.类型系统优势：避免了在开发过程中有可能的类型异常，提高编码效率和代码的可靠程度
//       2）.不仅支持对ES6+新功能，并且可以自动转换新特性，完全支持对陈旧环境中的兼容问题
//       3）.相较于FLOW,功能更为强大，生态更加健全、完善
//       4）.属于渐进式，可以初期完全作为JavaScript去使用，以后再了解一个特性，使用一个特性
//       5）.有利于长周期的大型项目代码管理，一劳永逸
// 缺点: 1）.语言本身多了很多概念（例如接口、泛型等），提高了学习成本
//       2）.项目初期，增加一些成本（增加很多类型声明的编写）
